# R-Type CI Workflow

name: CI

on:
  push:
    branches: [ "main" ]
    tags:
      - 'v*.*.*'
    paths-ignore:
      - "**/*.md"
      - "docs/**"
  pull_request:
    branches: [ "*" ]
  workflow_dispatch:

env:
  MIRROR_REPO_URL: "git@github.com:EpitechPGE3-2025/G-CPP-500-NAN-5-2-rtype-8.git"
  BUILDX_CACHE: /tmp/.buildx-cache

jobs:
  # -----------------------------
  # Detect Changes
  # -----------------------------
  check-changes:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
    outputs:
      server: ${{ steps.filter.outputs.server }}
      client: ${{ steps.filter.outputs.client }}
      ci: ${{ steps.filter.outputs.ci }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Filter paths
        uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            server:
              - 'server/**'
            client:
              - 'client/**'
            ci:
              - '.github/workflows/**'
              - 'scripts/**'
              - 'docker/**'
              - '.clang-format'
              - '.clang-tidy'

  # -----------------------------
  # Quick Check Repository
  # -----------------------------
  check_repository:
    runs-on: ubuntu-latest
    outputs:
      same_repository: ${{ steps.check_repo.outputs.same_repository }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Is this the mirror repository?
        id: check_repo
        run: |
          if [ "${{ github.event.repository.ssh_url }}" = "${{ env.MIRROR_REPO_URL }}" ]; then
            echo "::warning::Repository is the same as the mirror repository."
            echo "same_repository=true" >> $GITHUB_OUTPUT
          else
            echo "::notice::Repository is different from the mirror repository."
            echo "same_repository=false" >> $GITHUB_OUTPUT
          fi

  # -----------------------------
  # Build Environment Image
  # -----------------------------
  build-environment:
    name: Build Environment Image
    runs-on: ubuntu-latest
    outputs:
      image: rtype-build:latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Prepare cache directory
        run: |
          mkdir -p ${{ env.BUILDX_CACHE }}

      - name: Build Environment Image with cache
        uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/build.Dockerfile
          tags: rtype-build:latest
          load: true
          cache-from: type=local,src=${{ env.BUILDX_CACHE }}
          cache-to: type=local,dest=${{ env.BUILDX_CACHE }}-new,mode=max

      - name: Rotate buildx cache
        run: |
          rm -rf ${{ env.BUILDX_CACHE }} || true
          if [ -d "${{ env.BUILDX_CACHE }}-new" ]; then
            mv "${{ env.BUILDX_CACHE }}-new" "${{ env.BUILDX_CACHE }}"
          fi

  # -----------------------------
  # Linter (runs inside build image)
  # -----------------------------
  linter:
    name: Linter
    runs-on: ubuntu-latest
    needs: [build-environment, check-changes]
    if: github.event_name == 'workflow_dispatch' || needs.check-changes.outputs.ci == 'true' || needs.check-changes.outputs.server == 'true' || needs.check-changes.outputs.client == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run linter
        run: |
          docker run --rm -v $PWD:/work -w /work rtype-build:latest sh -c "
            chmod +x ./scripts/lint-check.sh || true
            echo "Running linter..."
            if [ -x ./scripts/lint-check.sh ]; then
              ./scripts/lint-check.sh
            else
              echo "No linter script found."
            fi
          "

  # -----------------------------
  # Build and Test (server + client) inside build image
  # Produces artifacts: build/server/r-type_server, build/client/r-type_client
  # -----------------------------
  build-and-test:
    name: Build & Test
    runs-on: ubuntu-latest
    needs: [build-environment, check-changes]
    if: github.event_name == 'workflow_dispatch' || needs.check-changes.outputs.server == 'true' || needs.check-changes.outputs.client == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Ensure ccache directory for runner
        run: |
          mkdir -p ~/.cache/ccache

      - name: Build and Test inside build container
        run: |
          docker run --rm \
            -v $PWD:/work \
            -v ~/.cache/ccache:/root/.cache/ccache \
            -w /work \
            rtype-build:latest sh -euxc "
              # Build server if changes or always build both to keep simple
              if [ -d server ] ; then
                cmake -S server -B build/server -DCMAKE_BUILD_TYPE=Release
                cmake --build build/server --target r-type_server -j$(nproc)
                if [ -f r-type_server ]; then
                  echo 'Server binary built at root'
                fi
                # run server tests if present
                if [ -d server/tests ]; then
                  cd build/server && ctest --output-on-failure || true
                fi
              fi

              # Build client if present
              # Temporarily disabled - no CMakeLists.txt yet
              # if [ -d client ] ; then
              #   cmake -S client -B build/client -DCMAKE_BUILD_TYPE=Release
              #   cmake --build build/client --target r-type_client -j$(nproc)
              #   if [ -f r-type_client ]; then
              #     echo 'Client binary built at root'
              #   fi
              #   # run client tests if present
              #   if [ -d client/tests ]; then
              #     cd build/client && ctest --output-on-failure || true
              #   fi
              # fi
            "

      - name: Upload Server Artifact (if exists)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: r-type_server-${{ runner.os }}
          path: r-type_server
          if-no-files-found: ignore
          

      - name: Upload Client Artifact (if exists)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: r-type_client-${{ runner.os }}
          path: r-type_client
          if-no-files-found: ignore

  # -----------------------------
  # Build Runtime Images (server + client) using cache
  # -----------------------------
  docker-build:
    name: Build Runtime Images
    runs-on: ubuntu-latest
    needs: build-and-test
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Prepare cache directory
        run: |
          mkdir -p /tmp/.buildx-cache-server
          mkdir -p /tmp/.buildx-cache-client

      - name: Build server runtime image with cache
        uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/server.Dockerfile
          tags: rtype-server:latest
          load: true
          cache-from: type=local,src=/tmp/.buildx-cache-server
          cache-to: type=local,dest=/tmp/.buildx-cache-server-new,mode=max
          

      - name: Build client runtime image with cache
        uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/client.Dockerfile
          tags: rtype-client:latest
          load: true
          cache-from: type=local,src=/tmp/.buildx-cache-client
          cache-to: type=local,dest=/tmp/.buildx-cache-client-new,mode=max

      - name: Rotate buildx cache
        run: |
          rm -rf /tmp/.buildx-cache-server || true
          rm -rf /tmp/.buildx-cache-client || true
          if [ -d "/tmp/.buildx-cache-server-new" ]; then
            mv "/tmp/.buildx-cache-server-new" "/tmp/.buildx-cache-server"
          fi
          if [ -d "/tmp/.buildx-cache-client-new" ]; then
            mv "/tmp/.buildx-cache-client-new" "/tmp/.buildx-cache-client"
          fi

  # -----------------------------
  # Create Release on Tag Push
  # -----------------------------
  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [ build-and-test, docker-build ]
    if: startsWith(github.ref, 'refs/tags/v')
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Server Artifact
        uses: actions/download-artifact@v4
        with:
          name: r-type_server-${{ runner.os }}
          path: artifacts
        continue-on-error: true

      - name: Download Client Artifact
        uses: actions/download-artifact@v4
        with:
          name: r-type_client-${{ runner.os }}
          path: artifacts
        continue-on-error: true

      - name: Prepare release package
        run: |
          mkdir -p release && cd artifacts
          FILES=""
          if [ -f ./r-type_server ]; then FILES="$FILES r-type_server"; fi
          if [ -f ./r-type_client ]; then FILES="$FILES r-type_client"; fi
          if [ -z "$FILES" ]; then
            echo "No artifacts found to include in the release."
            touch ../release/empty_release.txt
          else
            chmod +x $FILES
            tar -czvf ../release/r-type-${{ github.ref_name }}-linux-x64.tar.gz $FILES
          fi

      - name: Generate Release Notes
        id: notes
        run: |
          echo "## Release ${{ github.ref_name }}" > release_notes.md
          echo "" >> release_notes.md
          echo "### Changelog" >> release_notes.md
          git log --no-pager --pretty=format:"- %s" $(git describe --tags --abbrev=0 HEAD^)..HEAD >> release_notes.md 2>/dev/null || echo "- Initial release" >> release_notes.md

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: release/**
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # -----------------------------
  # Push to Mirror Repository
  # -----------------------------
  push-to-mirror:
    name: Push to Mirror Repository
    runs-on: ubuntu-latest
    needs: [check_repository, linter, build-and-test]
    if: needs.check-repository.outputs.same_repository == 'false' && needs.linter.result == 'success' && (needs.build-and-test.result == 'success' || needs.build-and-test.result == 'skipped')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: pixta-dev/repository-mirroring-action@v1
        with:
          target_repo_url: ${{ env.MIRROR_REPO_URL }}
          ssh_private_key: ${{ secrets.R_TYPE_SSH_KEY }}
